<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Practices</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxhtkj.github.io/"/>
  <updated>2018-10-21T02:18:16.537Z</updated>
  <id>https://lxhtkj.github.io/</id>
  
  <author>
    <name>LXHTKJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opencv</title>
    <link href="https://lxhtkj.github.io/2018/10/21/opencv/"/>
    <id>https://lxhtkj.github.io/2018/10/21/opencv/</id>
    <published>2018-10-21T02:18:16.000Z</published>
    <updated>2018-10-21T02:18:16.537Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lxhtkj.github.io/2018/10/21/hello-world/"/>
    <id>https://lxhtkj.github.io/2018/10/21/hello-world/</id>
    <published>2018-10-21T02:00:38.806Z</published>
    <updated>2018-10-21T02:00:38.806Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lxhtkj.github.io/2018/10/18/SpringCloud%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>https://lxhtkj.github.io/2018/10/18/SpringCloud提供的功能/</id>
    <published>2018-10-18T03:29:05.920Z</published>
    <updated>2018-10-19T09:20:51.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringCloud提供的功能"><a href="#SpringCloud提供的功能" class="headerlink" title="SpringCloud提供的功能"></a>SpringCloud提供的功能</h2><p>SpringCloud提供的功能包括：配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539931283231.png" alt="1539931283231"></p><p>1.Eureka </p><p><strong>说明</strong> 高可用组件，没有后端缓存，每一个实例注册之后需要向注册中心发送心跳。默认情况下Eureka Server也是一个Eureka Client，必须要指定一个Server.</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932208647.png" alt="1539932208647"></p><p>2.Starters</p><p>Spring Boot 启动项目，为Spring Cloud提供开箱即用的依赖管理。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932364851.png" alt="1539932364851"></p><p>3.Ribbon</p><p>提供远端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932481597.png" alt="1539932481597"></p><p>4.Feign</p><p>项目中包含Ribbon，因此也提供了负载均衡能力。它也是一种声明式、模板化的HTTP客户端。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932646536.png" alt="1539932646536"></p><p>5.Connectors</p><p>便于远端应用程序在各个pass平台连接到后端，如数据库和消息代理服务。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932548098.png" alt="1539932548098"></p><p>6.Zuul</p><p><strong>说明</strong> Zuul主要功能是 路由转发和过滤器。其配合Ribbon共同完成负载均衡。在Zuul中继承了ZuulFilter后，进行访问是，只有ZuulFilter校验通过了，才会进行后续Servlet服务的初始化。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932731418.png" alt="1539932731418"></p><p>7.Config</p><p><strong>说明</strong> 配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git、Subversion。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932851310.png" alt="1539932851310"></p><p>config-server和config-client</p><p>在properties文件中添加远程配置中心如$[git]$等</p><p>http请求地址和资源文件映射如下：<br>$$<br>\begin{align}<br>/{applicaion}/{profile}[/{label}]\tag{1}\<br> /{applicaion}-{profile}[/{label}]\tag{2}\<br> /{label}/{applicaion}-{profile}\tag{3}\<br>/{applicaion}-{profile}.properties\tag{4}\<br> /{label}/{applicaion}-{profile}.properties\tag{3}\<br>\end{align}<br>$$<br>8.Bus</p><p><strong>说明</strong> 事件、消息总线，用于在集群中传播状态变化、可与Config联合实现热部署。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539932946098.png" alt="1539932946098"></p><p>9.Hystrix</p><p><strong>说明</strong> 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933050036.png" alt="1539933050036"></p><p>10.Archaius</p><p><strong>说明</strong> 配置管理API：包含一系列配置管理API，提供动态类型化属性，线程安全配置操作、轮询框架、回调机制等功能。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933254062.png" alt="1539933254062"></p><p>11.Cloud Foundry</p><p><strong>说明</strong> 通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源Paas云平台。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933484109.png" alt="1539933484109"></p><p>12.Security</p><p><strong>说明</strong> 基于SpringSecurity的安全工具包，为应用程序添加安全控制。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933561376.png" alt="1539933561376"></p><p>13.Consul</p><p><strong>说明</strong> 封装了Consul操作，consul是一个服务发现与配置工具，与Docker可以无缝集成。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933668398.png" alt="1539933668398"></p><p>14.Zookeeper</p><p><strong>说明</strong> 操作Zookeeper的工具包，用于使用Zookeeper方式的服务发现和配置管理。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933745314.png" alt="1539933745314"></p><p>15.Sleuth</p><p><strong>说明</strong> 日志收集工具，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933873473.png" alt="1539933873473"></p><p>16.Data Flow</p><p><strong>说明</strong> 大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539933970622.png" alt="1539933970622"></p><p>17.Stream</p><p><strong>说明</strong> 数据流操作开发包，封装了与Redis，Rabbit，Kafka等发送接收消息。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539934097902.png" alt="1539934097902"></p><p>18.Task</p><p><strong>说明</strong> 提供云端计划任务管理，任务调度。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539934149908.png" alt="1539934149908"></p><p>19.Turbine</p><p><strong>说明</strong> Turbine是服务器发送事件流数据的一个工具，用来监控集群下Hystrix的metrics情况。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539940720984.png" alt="1539940720984"></p><p>20.Cluster</p><p><strong>说明</strong> 提供Leadership选举，如：Zookeeper，Redis，Hazeicast，Consul等常见状态模式的抽象和实现。</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1539940844567.png" alt="1539940844567"></p><p>特点</p><blockquote><ol><li>约定由于配置</li><li>开箱即用，快速启动</li><li>适用于各种环境</li><li>轻量级组件</li><li>组建支持丰富，功能齐全</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringCloud提供的功能&quot;&gt;&lt;a href=&quot;#SpringCloud提供的功能&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud提供的功能&quot;&gt;&lt;/a&gt;SpringCloud提供的功能&lt;/h2&gt;&lt;p&gt;SpringCloud提供的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lxhtkj.github.io/2018/10/15/Channel/"/>
    <id>https://lxhtkj.github.io/2018/10/15/Channel/</id>
    <published>2018-10-15T08:44:09.314Z</published>
    <updated>2018-10-16T01:49:39.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="1-1常用方法说明"><a href="#1-1常用方法说明" class="headerlink" title="1.1常用方法说明"></a>1.1常用方法说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Channel channels = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExectors.INSTANCE);</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span>  <span class="comment">//加入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel joinChannel = ctx.channel();</span><br><span class="line">    <span class="keyword">for</span>(Channel channel:channels)&#123;</span><br><span class="line">        sout(<span class="string">"Address: "</span> + channel.remoteAddress() +<span class="string">"加入服务端……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    channels.add(joinChannel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span>  <span class="comment">//移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandlerRemove</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Channel removeChannel = ctx.channel();</span><br><span class="line">    <span class="keyword">for</span>(Channel channel:channels)&#123;</span><br><span class="line">        sout(<span class="string">"Address: "</span> + channel.remoteAddress() +<span class="string">"加入服务端……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    channels.add(removeChannel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span> <span class="comment">//读取完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span>  <span class="comment">//在线</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelActive</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@override</span> <span class="comment">//不在线</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelInActive</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@override</span> <span class="comment">//异常处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel incoming = ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">"SimpleChatClient:"</span>+incoming.remoteAddress()+<span class="string">"异常"</span>);</span><br><span class="line">        <span class="comment">// 当出现异常就关闭连接</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2.引用计数"></a>2.引用计数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ctx.alloc().directBuffer();<span class="comment">//新创建的引用对象的初始值为1</span></span><br><span class="line"><span class="keyword">assert</span> buf.refCnt()==<span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> destoryed = buf.release();<span class="comment">//释放引用计数对象，引用次数就减1，为0时就归还到创建它的对象池</span></span><br><span class="line"><span class="comment">//引用技术对象未销毁时，可以通过retain()方法增加引用次数</span></span><br><span class="line">buf.retain();</span><br><span class="line"><span class="keyword">assert</span> buf.refCnt() == <span class="number">2</span>;</span><br><span class="line"><span class="comment">//销毁对象通过最后访问引用计数对象的部分负责对象的销毁</span></span><br><span class="line">buf.release();</span><br><span class="line"><span class="keyword">assert</span> buf.refCnt() == <span class="number">1</span>;</span><br><span class="line"><span class="comment">//子缓冲区 duplicate(),slice(),order(ByteOrder)方法会创建一个子缓冲区，子缓冲区共享父缓冲区的内存区域。子缓冲区没有自己的引用技术，而是共享父缓冲区的引用计数</span></span><br><span class="line">ByteBuf derived = buf.duplicate();</span><br><span class="line"><span class="keyword">assert</span> buf.refCnt() == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assert</span> derived.refCnt() == <span class="number">1</span>;</span><br><span class="line"><span class="comment">//buf.copy()和buf.readBytes(int)创建的不是子缓冲区，因此返回的ByteBuf需要释放。由于父缓冲区和子缓冲区共享引用技术，因此在将子缓冲区对象传递到其他组件时，需要先调用retain()</span></span><br><span class="line">      ByteBuf parent = ctx.alloc().directBuffer();</span><br><span class="line">        parent.writeByte(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(parent.isReadable(<span class="number">16</span>))&#123;</span><br><span class="line">                ByteBuf derived = parent.readSlice(<span class="number">16</span>);</span><br><span class="line">                derived.retain();</span><br><span class="line">                process(derived);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            parent.release();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ByteBuf buf)</span></span>&#123;</span><br><span class="line">    buf.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Channel&quot;&gt;&lt;a href=&quot;#Channel&quot; class=&quot;headerlink&quot; title=&quot;Channel&quot;&gt;&lt;/a&gt;Channel&lt;/h2&gt;&lt;h3 id=&quot;1-1常用方法说明&quot;&gt;&lt;a href=&quot;#1-1常用方法说明&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lxhtkj.github.io/2018/10/12/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <id>https://lxhtkj.github.io/2018/10/12/算法复杂度计算/</id>
    <published>2018-10-12T07:16:26.862Z</published>
    <updated>2018-10-15T02:10:34.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：渐进符号"><a href="#一：渐进符号" class="headerlink" title="一：渐进符号"></a>一：渐进符号</h2><h3 id="1-1-符号的辨析"><a href="#1-1-符号的辨析" class="headerlink" title="1.1 符号的辨析"></a>1.1 符号的辨析</h3><h4 id="1-1-1-符号-O"><a href="#1-1-1-符号-O" class="headerlink" title="1.1.1 符号$O$"></a>1.1.1 符号$O$</h4><p>$O$,读作“大O”,非正式来说，$O(g(n))$是增长次数小于等于$g(n)$及其常数倍($n$趋向于无穷大)的函数集合。</p><p><strong>定义</strong> 如果函数$f(n)$包含在$O(g(n))$中，记作$f(n)∈o(g(n))$ (平时使用为了方便书写，我们通常使用$f(n)=o(g(n)))$代替)。它的成立条件是：对于所有足够大的$n$,$f(n)$上界由$g(n)$的常数倍确定，也就是说：存在大于$O$的常数$c$和非负整数$n_0$，使得对于所有的$n≥n_0$来说，$f(n)≤c(g(n))$。</p><p>下图说明了这个定义：</p><p><img src="https://subetter.com/images/figures/20180405_01.png" alt=" "></p><p>下面给出几个例子：<br>$$<br>\begin{align}<br>n&amp;=O(n^2)\tag{1.1.1.1}\<br>100n+5&amp;=O(n^2)\tag{1.1.1.2}\<br>\frac 12n(n-1)&amp;=O(n^2)\tag{1.1.1.3}\<br>n^3&amp;≠O(n^2)\tag{1.1.1.4}\<br>0.00001n^3&amp;≠O(n^2)\tag{1.1.1.5}<br>\end{align}<br>$$</p><h4 id="1-1-2-符号-Ω"><a href="#1-1-2-符号-Ω" class="headerlink" title="1.1.2 符号$Ω$"></a>1.1.2 符号$Ω$</h4><p>$Ω$读作”omega”,$Ω(g(n))$是增长次数大于等于$g(n)$及其常数倍($n$趋向于无穷大)的函数集。</p><p><strong>定义</strong> 如果函数$f(n)$包含在$Ω(g(n))$中，记作$f(n)=Ω(g(n))$。它的成立条件是：对于所有足够大的$n$,$f(n)$的下届由$g(n)$的常数倍确定，也就是说，存在大于$0$的常数$c$和非负整数$n_0$，使得对于所有的$f(n)≥c g(n)$。</p><p>下图说明了这个定义：</p><p><img src="https://subetter.com/images/figures/20180405_02.png" alt=""></p><p>下面给出几个例子：<br>$$<br>\begin{align}<br>n^3&amp;=Ω(n^2)\tag{1.1.2.1}\<br>\frac 12n(n-1)&amp;=Ω(n^2)\tag{1.1.2.2}\<br>100n+5&amp;=Ω(n^2)\tag{1.1.2.3}\<br>\end{align}<br>$$</p><h4 id="1-1-3-符号-θ"><a href="#1-1-3-符号-θ" class="headerlink" title="1.1.3 符号$θ$"></a>1.1.3 符号$θ$</h4><p>$θ$读作”theta”。</p><p><strong>定义</strong> 如果函数$f(n)$包含在$θ(g(n))$中，记作$f(n)=θ(g(n))$。它的成立条件是：对于所有足够大的$n$，$f(n)$的上界和下界由$g(n)$的常数倍所确定，也即是说：存在大于$0$的常数$c_1,c_2$和非负整数$n_0$，使得对于所有的$n≥n_0$来说，$c_1·g(n)≤f(n)≤c_2·g(n)$。</p><p>下图说明了这个定义：</p><p><img src="https://subetter.com/images/figures/20180405_03.png" alt=""><br>$$<br>\begin{align}<br>\frac 12n(n-1)&amp;=θ(n^2)\tag{$c_1=\frac 14,c_2=\frac 12,n_0=2$}\<br>6n^3&amp;≠θ(n^2)\tag{1.1.3.2}\<br>\end{align}<br>$$</p><h3 id="1-2-符号的性质"><a href="#1-2-符号的性质" class="headerlink" title="1.2 符号的性质"></a>1.2 符号的性质</h3><p><strong>定理</strong> 如果$t_1(n)=O(g_1(n))$并且$t_2(n)=O(g_2(n))$，则:<br>$$<br>t_1(n)+t_2(n)=O(\max{g_1(n),g_2(n)})<br>$$<br>对于$Ω$和$θ$同样成立。</p><p><strong>证明</strong> 增长次数的证明是基于以下事实：对于$4$个任意的实数$a_1,b_1,a_2,b_2$,如果$a_1≤b_1$并且$a_2≤b_2$，则$a_1+a_2≤2\max{b_1,b_2}$。</p><p>因为$t_1(n)=O(g_1(n))$，所以在正常量$c_1$和非负整数$n_1$，使得对于所有的$n≥n_1$，有$t_1(n)≤c_1g_1(n)$。同理，因为$t_2(n)=O(g_2(n))$，对于所有的$n≥n_2$，亦有$t_2(n)≤c_2g_2(n)$。</p><p>假设$c_3=\max{c_1,c_2}$并且$n≥\max{n_1,n_2}$，就可以利用两个不等式的结论将其相加，得出以下结论：<br>$$<br>\begin{align}<br>t_1(n)+t_2(n)&amp;≤c_1g_1(n)+c_2g_2(n)\tag{1.2.1}\<br>                      &amp;≤c_3g_1(n)+c_3g_2(n)=c_3[g_1(n)+g_2(n)]\tag{1.2.2}\<br>                      &amp;≤c_3·2\max{g_1(n),g_2(n)}\tag{1.2.3}<br>  \end{align}<br>$$<br>那么，对于<strong>两个连续执行部分</strong>组成的算法，应该如何应用这个特征呢？<strong>它意味着该算法的整体效率是由具有较大增长次数的部分所决定的，即效率较差的部分决定</strong>。</p><h2 id="二：计算复杂度"><a href="#二：计算复杂度" class="headerlink" title="二：计算复杂度"></a>二：计算复杂度</h2><p>对于一个普通的函数(即非递归函数)，其时间复杂度自然易求。下面说下递归函数的时间复杂度。</p><p>递归函数的时间复杂度有以下的方程式 :<br>$$<br>T(n)=aT(\frac nb)+f(n)\tag{2.1}<br>$$<br>其中，$a≥1,b&gt;1$并且都是常数，$f(n)$是渐进正函数。递归式$(2.1)$描述的是这样一种算法的运行时间：它将规模为$n$的问题分解为$a$个子问题，每个子问题规模为$\frac nb$，其中$a≥1,b&gt;1$。$a$个子问题递归地求解，每个花费的时间$T(\frac nb)$。函数$f(n)$包含了问题分解和子问题解合并的代价。</p><p>解决以上方程式常用的方法有两种：<strong>主定理</strong>和<strong>分治法</strong>。</p><h3 id="2-1-主定理-Master-Theorem"><a href="#2-1-主定理-Master-Theorem" class="headerlink" title="2.1 主定理(Master Theorem)"></a>2.1 主定理(Master Theorem)</h3><p><strong>定理</strong> 令$a≥1,b&gt;1$且都是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式，即:<br>$$<br>T(n) = aT(\frac nb)+f(n)<br>$$<br>其中，我们将$\frac nb$解释为$⌊\frac nb⌋$或$⌈\frac nb⌉$。那么$T(n)$有如下渐近界：</p><p>(Case 1) 如果$f(n)=O(n^c)$，其中$c&lt;log_ba$，则：<br>$$<br>T(n) = θ(b^{log_ba})<br>$$<br>(Case 2) 如果存在常数$k≥0$，使$f(n)=θ(n^clog^{k}n)$，其中$c=log_ba$，则：<br>$$<br>T(n)=θ(n^clog^{k+1}n)<br>$$</p><p>(Case 3) 如果$f(n)=Ω(n^c)$，其中$c&gt;log_ba$，并且对某个常数$k&lt;1$和所有足够大的$n$有$af(\frac nb)≤kf(n)$，则：</p><p>$$<br>T(n)=θ(f(n))<br>$$</p><p>算法导论已有关于这个定理的证明，篇幅较长，故此处省略，有兴趣的读者可以自己去翻阅下。</p><h3 id="2-2-分治法"><a href="#2-2-分治法" class="headerlink" title="2.2 分治法"></a>2.2 分治法</h3><p>分治法先把给定的实例划分为若干个较小的实例，对每个实例递归求解，然后如果有必要，再把较小实例的解合并成给定实例的一个解。假设所有较小实例的规模都为$\frac nb$，其中$a$个实例需要实际求解，对于$n=b^k,k=1,2,3…$，其中$a≥1,b&gt;1$，得到以下结果：</p><p>$$<br>\begin{align}<br>T(n)&amp;=aT(\frac nb)+f(n)\tag{原始递归方程式}\<br>T(b^k)&amp;=aT(b^{k-1})+f(b^k)\tag{2.2.2}\<br>      &amp;=a[aT(b^{k-2})+f(b^{k-1})]+f(b^k)=a^2T(b^{k-2})+af(b^{k-1})+f(b^k)\tag{2.2.3}\<br>      &amp;=a^3T(b^{k-3})+a^2f(b^{k-2})+af(b^{k-1})+f(b^k)\tag{2.2.4}\<br>      &amp;=…\tag{2.2.5}\<br>      &amp;=a^kT(1)+a^{k-1}f(b^1)+a^{k-2}f(b^2)+…+a^0f(b^k)\tag{2.2.6}\<br>      &amp;=a^k[T(1)+\sum_{j=1}^{k} {\frac {f(b^j)}{a^j}}]\tag{2.2.7}<br>\end{align}<br>$$</p><p>由于$a^k=a^{log_bn}=n^{log_ba}​$,当$n=b^k​$时，对于式$(2.2.7)​$我们可以推出下式：</p><p>$$<br>T(n)=n^{log_ba}[T(1)+\sum_{j=1}^{log_bn}{\frac {f(b^j)}{a^j}}]\tag{2.2.8}<br>$$</p><p>显然，<strong>$T(n)$的增长次数取决于常数$a$和$b$的值以及函数$f(n)$的增长次数。</strong></p><h2 id="三：常见的定理"><a href="#三：常见的定理" class="headerlink" title="三：常见的定理"></a>三：常见的定理</h2><p>以下是常用的的两条定理，它们依旧建立在递归方程式中，即：</p><p>$$<br>T(n)=aT(\frac nb)+f(n)\tag{$a≥1,b&gt;1$}<br>$$</p><p>根据以上的方程式有以下两个定理：</p><h3 id="3-1-定理1"><a href="#3-1-定理1" class="headerlink" title="3.1 定理1"></a>3.1 定理1</h3><p><strong>定理1</strong> 对于递归方程式，若$a=1,b&gt;1,f(n)=c,c$为某个常数，即：</p><p>$$<br>T(n)=T(\frac nb)+c<br>$$</p><p>则：</p><p>$$<br>T(n)=Θ(logn)<br>$$</p><p><strong>证明</strong> 应用主定理 Case 2，其中$c=log_ba=log_b1=0​$，再使$k=0​$，则$f(n)=Θ(n^clog^kn)=Θ(1)​$，这里的$f(n)​$即等于常数$c​$，证明成立。</p><h3 id="3-2-定理2"><a href="#3-2-定理2" class="headerlink" title="3.2 定理2"></a>3.2 定理2</h3><p><strong>定理2</strong> 对于递归方程式，若$a=1,b&gt;1,f(n)=kn+p$，其中$k&gt;0,p&gt;0$且为某个常数（也就是$f(n)$是一个线性直线方程），即：</p><p>$$<br>T(n)=T(\frac nb)+(kn+p)\tag{$b&gt;1,k&gt;0,p$为某个常数}<br>$$</p><p>则：</p><p>$$<br>T(n)=Θ(n)<br>$$</p><p><strong>证明</strong> 应用分治法中式$(2.2.8)$：</p><p>$$<br>\begin{align}<br>T(n)&amp;=n^{log_ba}[T(1)+\sum_{j=1}^{log_bn}{\frac {f(b^j)} {a^j}}]\tag{3.2.1}\<br>&amp;=\sum_{j=1}^{log_bn}(kb^j+p)\tag{3.2.2}\<br>&amp;=plog_bn+{\frac {kb}{b-1}(n-1)}\tag{k&gt;0,p&gt;0,b&gt;1}\<br>&amp;&lt;pn+{\frac{kb}{b-1}(n-1)}\tag{3.2.4}\<br>&amp;=cn - {\frac {kb}{b-1}}\tag{c&gt;0且为某个常数}\<br>&amp;=θ(n)\tag{3.2.5}<br>\end{align}<br>$$</p><p>证明成立。</p><h2 id="四：总结"><a href="#四：总结" class="headerlink" title="四：总结"></a>四：总结</h2><p>第一部分辨析了$O,Ω,Θ$三种符号的区别以及它们的性质。</p><p>第二部分介绍了两种常用的计算时间复杂度方法，即主定理和分治法。</p><p>第三部分给出了生活中常见的两个定理，比较实用，希望读者能够熟记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一：渐进符号&quot;&gt;&lt;a href=&quot;#一：渐进符号&quot; class=&quot;headerlink&quot; title=&quot;一：渐进符号&quot;&gt;&lt;/a&gt;一：渐进符号&lt;/h2&gt;&lt;h3 id=&quot;1-1-符号的辨析&quot;&gt;&lt;a href=&quot;#1-1-符号的辨析&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
</feed>
