<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[opencv]]></title>
    <url>%2F2018%2F10%2F21%2Fopencv%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F18%2FSpringCloud%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[SpringCloud提供的功能SpringCloud提供的功能包括：配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等。 1.Eureka 说明 高可用组件，没有后端缓存，每一个实例注册之后需要向注册中心发送心跳。默认情况下Eureka Server也是一个Eureka Client，必须要指定一个Server. 2.Starters Spring Boot 启动项目，为Spring Cloud提供开箱即用的依赖管理。 3.Ribbon 提供远端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。 4.Feign 项目中包含Ribbon，因此也提供了负载均衡能力。它也是一种声明式、模板化的HTTP客户端。 5.Connectors 便于远端应用程序在各个pass平台连接到后端，如数据库和消息代理服务。 6.Zuul 说明 Zuul主要功能是 路由转发和过滤器。其配合Ribbon共同完成负载均衡。在Zuul中继承了ZuulFilter后，进行访问是，只有ZuulFilter校验通过了，才会进行后续Servlet服务的初始化。 7.Config 说明 配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git、Subversion。 config-server和config-client 在properties文件中添加远程配置中心如$[git]$等 http请求地址和资源文件映射如下：$$\begin{align}/{applicaion}/{profile}[/{label}]\tag{1}\ /{applicaion}-{profile}[/{label}]\tag{2}\ /{label}/{applicaion}-{profile}\tag{3}\/{applicaion}-{profile}.properties\tag{4}\ /{label}/{applicaion}-{profile}.properties\tag{3}\\end{align}$$8.Bus 说明 事件、消息总线，用于在集群中传播状态变化、可与Config联合实现热部署。 9.Hystrix 说明 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。 10.Archaius 说明 配置管理API：包含一系列配置管理API，提供动态类型化属性，线程安全配置操作、轮询框架、回调机制等功能。 11.Cloud Foundry 说明 通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源Paas云平台。 12.Security 说明 基于SpringSecurity的安全工具包，为应用程序添加安全控制。 13.Consul 说明 封装了Consul操作，consul是一个服务发现与配置工具，与Docker可以无缝集成。 14.Zookeeper 说明 操作Zookeeper的工具包，用于使用Zookeeper方式的服务发现和配置管理。 15.Sleuth 说明 日志收集工具，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。 16.Data Flow 说明 大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。 17.Stream 说明 数据流操作开发包，封装了与Redis，Rabbit，Kafka等发送接收消息。 18.Task 说明 提供云端计划任务管理，任务调度。 19.Turbine 说明 Turbine是服务器发送事件流数据的一个工具，用来监控集群下Hystrix的metrics情况。 20.Cluster 说明 提供Leadership选举，如：Zookeeper，Redis，Hazeicast，Consul等常见状态模式的抽象和实现。 特点 约定由于配置 开箱即用，快速启动 适用于各种环境 轻量级组件 组建支持丰富，功能齐全]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F15%2FChannel%2F</url>
    <content type="text"><![CDATA[Channel1.1常用方法说明123456789101112131415161718192021222324252627282930313233343536373839404142private static Channel channels = new DefaultChannelGroup(GlobalEventExectors.INSTANCE);@override //加入public void handlerAdded(ChannelHandlerContext ctx)throws Exception&#123; Channel joinChannel = ctx.channel(); for(Channel channel:channels)&#123; sout("Address: " + channel.remoteAddress() +"加入服务端……"); &#125; channels.add(joinChannel);&#125;@override //移除public void HandlerRemove(ChannelHandlerContext ctx)throws Exception&#123; Channel removeChannel = ctx.channel(); for(Channel channel:channels)&#123; sout("Address: " + channel.remoteAddress() +"加入服务端……"); &#125; channels.add(removeChannel);&#125;@override //读取完成public void ChannelReadComplete(ChannelHandlerContext ctx)throws Exception&#123; &#125;@override //在线public void ChannelActive(ChannelHandlerContext ctx)throws Exception&#123; &#125;@override //不在线public void ChannelInActive(ChannelHandlerContext ctx)throws Exception&#123; &#125;@override //异常处理public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception &#123; Channel incoming = ctx.channel(); System.out.println("SimpleChatClient:"+incoming.remoteAddress()+"异常"); // 当出现异常就关闭连接 cause.printStackTrace(); ctx.close();&#125; 2.引用计数1234567891011121314151617181920212223242526272829ByteBuf buf = ctx.alloc().directBuffer();//新创建的引用对象的初始值为1assert buf.refCnt()==1;boolean destoryed = buf.release();//释放引用计数对象，引用次数就减1，为0时就归还到创建它的对象池//引用技术对象未销毁时，可以通过retain()方法增加引用次数buf.retain();assert buf.refCnt() == 2;//销毁对象通过最后访问引用计数对象的部分负责对象的销毁buf.release();assert buf.refCnt() == 1;//子缓冲区 duplicate(),slice(),order(ByteOrder)方法会创建一个子缓冲区，子缓冲区共享父缓冲区的内存区域。子缓冲区没有自己的引用技术，而是共享父缓冲区的引用计数ByteBuf derived = buf.duplicate();assert buf.refCnt() == 1;assert derived.refCnt() == 1;//buf.copy()和buf.readBytes(int)创建的不是子缓冲区，因此返回的ByteBuf需要释放。由于父缓冲区和子缓冲区共享引用技术，因此在将子缓冲区对象传递到其他组件时，需要先调用retain() ByteBuf parent = ctx.alloc().directBuffer(); parent.writeByte(16); try&#123; while(parent.isReadable(16))&#123; ByteBuf derived = parent.readSlice(16); derived.retain(); process(derived); &#125; &#125; finally&#123; parent.release(); &#125;public void process(ByteBuf buf)&#123; buf.release();&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F12%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[一：渐进符号1.1 符号的辨析1.1.1 符号$O$$O$,读作“大O”,非正式来说，$O(g(n))$是增长次数小于等于$g(n)$及其常数倍($n$趋向于无穷大)的函数集合。 定义 如果函数$f(n)$包含在$O(g(n))$中，记作$f(n)∈o(g(n))$ (平时使用为了方便书写，我们通常使用$f(n)=o(g(n)))$代替)。它的成立条件是：对于所有足够大的$n$,$f(n)$上界由$g(n)$的常数倍确定，也就是说：存在大于$O$的常数$c$和非负整数$n_0$，使得对于所有的$n≥n_0$来说，$f(n)≤c(g(n))$。 下图说明了这个定义： 下面给出几个例子：$$\begin{align}n&amp;=O(n^2)\tag{1.1.1.1}\100n+5&amp;=O(n^2)\tag{1.1.1.2}\\frac 12n(n-1)&amp;=O(n^2)\tag{1.1.1.3}\n^3&amp;≠O(n^2)\tag{1.1.1.4}\0.00001n^3&amp;≠O(n^2)\tag{1.1.1.5}\end{align}$$ 1.1.2 符号$Ω$$Ω$读作”omega”,$Ω(g(n))$是增长次数大于等于$g(n)$及其常数倍($n$趋向于无穷大)的函数集。 定义 如果函数$f(n)$包含在$Ω(g(n))$中，记作$f(n)=Ω(g(n))$。它的成立条件是：对于所有足够大的$n$,$f(n)$的下届由$g(n)$的常数倍确定，也就是说，存在大于$0$的常数$c$和非负整数$n_0$，使得对于所有的$f(n)≥c g(n)$。 下图说明了这个定义： 下面给出几个例子：$$\begin{align}n^3&amp;=Ω(n^2)\tag{1.1.2.1}\\frac 12n(n-1)&amp;=Ω(n^2)\tag{1.1.2.2}\100n+5&amp;=Ω(n^2)\tag{1.1.2.3}\\end{align}$$ 1.1.3 符号$θ$$θ$读作”theta”。 定义 如果函数$f(n)$包含在$θ(g(n))$中，记作$f(n)=θ(g(n))$。它的成立条件是：对于所有足够大的$n$，$f(n)$的上界和下界由$g(n)$的常数倍所确定，也即是说：存在大于$0$的常数$c_1,c_2$和非负整数$n_0$，使得对于所有的$n≥n_0$来说，$c_1·g(n)≤f(n)≤c_2·g(n)$。 下图说明了这个定义： $$\begin{align}\frac 12n(n-1)&amp;=θ(n^2)\tag{$c_1=\frac 14,c_2=\frac 12,n_0=2$}\6n^3&amp;≠θ(n^2)\tag{1.1.3.2}\\end{align}$$ 1.2 符号的性质定理 如果$t_1(n)=O(g_1(n))$并且$t_2(n)=O(g_2(n))$，则:$$t_1(n)+t_2(n)=O(\max{g_1(n),g_2(n)})$$对于$Ω$和$θ$同样成立。 证明 增长次数的证明是基于以下事实：对于$4$个任意的实数$a_1,b_1,a_2,b_2$,如果$a_1≤b_1$并且$a_2≤b_2$，则$a_1+a_2≤2\max{b_1,b_2}$。 因为$t_1(n)=O(g_1(n))$，所以在正常量$c_1$和非负整数$n_1$，使得对于所有的$n≥n_1$，有$t_1(n)≤c_1g_1(n)$。同理，因为$t_2(n)=O(g_2(n))$，对于所有的$n≥n_2$，亦有$t_2(n)≤c_2g_2(n)$。 假设$c_3=\max{c_1,c_2}$并且$n≥\max{n_1,n_2}$，就可以利用两个不等式的结论将其相加，得出以下结论：$$\begin{align}t_1(n)+t_2(n)&amp;≤c_1g_1(n)+c_2g_2(n)\tag{1.2.1}\ &amp;≤c_3g_1(n)+c_3g_2(n)=c_3[g_1(n)+g_2(n)]\tag{1.2.2}\ &amp;≤c_3·2\max{g_1(n),g_2(n)}\tag{1.2.3} \end{align}$$那么，对于两个连续执行部分组成的算法，应该如何应用这个特征呢？它意味着该算法的整体效率是由具有较大增长次数的部分所决定的，即效率较差的部分决定。 二：计算复杂度对于一个普通的函数(即非递归函数)，其时间复杂度自然易求。下面说下递归函数的时间复杂度。 递归函数的时间复杂度有以下的方程式 :$$T(n)=aT(\frac nb)+f(n)\tag{2.1}$$其中，$a≥1,b&gt;1$并且都是常数，$f(n)$是渐进正函数。递归式$(2.1)$描述的是这样一种算法的运行时间：它将规模为$n$的问题分解为$a$个子问题，每个子问题规模为$\frac nb$，其中$a≥1,b&gt;1$。$a$个子问题递归地求解，每个花费的时间$T(\frac nb)$。函数$f(n)$包含了问题分解和子问题解合并的代价。 解决以上方程式常用的方法有两种：主定理和分治法。 2.1 主定理(Master Theorem)定理 令$a≥1,b&gt;1$且都是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式，即:$$T(n) = aT(\frac nb)+f(n)$$其中，我们将$\frac nb$解释为$⌊\frac nb⌋$或$⌈\frac nb⌉$。那么$T(n)$有如下渐近界： (Case 1) 如果$f(n)=O(n^c)$，其中$c&lt;log_ba$，则：$$T(n) = θ(b^{log_ba})$$(Case 2) 如果存在常数$k≥0$，使$f(n)=θ(n^clog^{k}n)$，其中$c=log_ba$，则：$$T(n)=θ(n^clog^{k+1}n)$$ (Case 3) 如果$f(n)=Ω(n^c)$，其中$c&gt;log_ba$，并且对某个常数$k&lt;1$和所有足够大的$n$有$af(\frac nb)≤kf(n)$，则： $$T(n)=θ(f(n))$$ 算法导论已有关于这个定理的证明，篇幅较长，故此处省略，有兴趣的读者可以自己去翻阅下。 2.2 分治法分治法先把给定的实例划分为若干个较小的实例，对每个实例递归求解，然后如果有必要，再把较小实例的解合并成给定实例的一个解。假设所有较小实例的规模都为$\frac nb$，其中$a$个实例需要实际求解，对于$n=b^k,k=1,2,3…$，其中$a≥1,b&gt;1$，得到以下结果： $$\begin{align}T(n)&amp;=aT(\frac nb)+f(n)\tag{原始递归方程式}\T(b^k)&amp;=aT(b^{k-1})+f(b^k)\tag{2.2.2}\ &amp;=a[aT(b^{k-2})+f(b^{k-1})]+f(b^k)=a^2T(b^{k-2})+af(b^{k-1})+f(b^k)\tag{2.2.3}\ &amp;=a^3T(b^{k-3})+a^2f(b^{k-2})+af(b^{k-1})+f(b^k)\tag{2.2.4}\ &amp;=…\tag{2.2.5}\ &amp;=a^kT(1)+a^{k-1}f(b^1)+a^{k-2}f(b^2)+…+a^0f(b^k)\tag{2.2.6}\ &amp;=a^k[T(1)+\sum_{j=1}^{k} {\frac {f(b^j)}{a^j}}]\tag{2.2.7}\end{align}$$ 由于$a^k=a^{log_bn}=n^{log_ba}​$,当$n=b^k​$时，对于式$(2.2.7)​$我们可以推出下式： $$T(n)=n^{log_ba}[T(1)+\sum_{j=1}^{log_bn}{\frac {f(b^j)}{a^j}}]\tag{2.2.8}$$ 显然，$T(n)$的增长次数取决于常数$a$和$b$的值以及函数$f(n)$的增长次数。 三：常见的定理以下是常用的的两条定理，它们依旧建立在递归方程式中，即： $$T(n)=aT(\frac nb)+f(n)\tag{$a≥1,b&gt;1$}$$ 根据以上的方程式有以下两个定理： 3.1 定理1定理1 对于递归方程式，若$a=1,b&gt;1,f(n)=c,c$为某个常数，即： $$T(n)=T(\frac nb)+c$$ 则： $$T(n)=Θ(logn)$$ 证明 应用主定理 Case 2，其中$c=log_ba=log_b1=0​$，再使$k=0​$，则$f(n)=Θ(n^clog^kn)=Θ(1)​$，这里的$f(n)​$即等于常数$c​$，证明成立。 3.2 定理2定理2 对于递归方程式，若$a=1,b&gt;1,f(n)=kn+p$，其中$k&gt;0,p&gt;0$且为某个常数（也就是$f(n)$是一个线性直线方程），即： $$T(n)=T(\frac nb)+(kn+p)\tag{$b&gt;1,k&gt;0,p$为某个常数}$$ 则： $$T(n)=Θ(n)$$ 证明 应用分治法中式$(2.2.8)$： $$\begin{align}T(n)&amp;=n^{log_ba}[T(1)+\sum_{j=1}^{log_bn}{\frac {f(b^j)} {a^j}}]\tag{3.2.1}\&amp;=\sum_{j=1}^{log_bn}(kb^j+p)\tag{3.2.2}\&amp;=plog_bn+{\frac {kb}{b-1}(n-1)}\tag{k&gt;0,p&gt;0,b&gt;1}\&amp;&lt;pn+{\frac{kb}{b-1}(n-1)}\tag{3.2.4}\&amp;=cn - {\frac {kb}{b-1}}\tag{c&gt;0且为某个常数}\&amp;=θ(n)\tag{3.2.5}\end{align}$$ 证明成立。 四：总结第一部分辨析了$O,Ω,Θ$三种符号的区别以及它们的性质。 第二部分介绍了两种常用的计算时间复杂度方法，即主定理和分治法。 第三部分给出了生活中常见的两个定理，比较实用，希望读者能够熟记。]]></content>
  </entry>
</search>
