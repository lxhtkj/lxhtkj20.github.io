<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F22%2F%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%A7%80%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[高可用服务端架构的优秀资料 高可用 探究高可用服务端架构的优秀资料索引从属于笔者的 服务端应用程序开发与系统架构 系列文章；最近随着公司业务的发展与终端用户的增加，保证系统的高可用性也日渐成为团队考虑的重要因素，笔者也把去年以来看的一些文章归集整理，抛砖引玉，如果有其他优秀的望不吝赐教。 探究高可用服务端架构的优秀资料索引本文是对于服务端应用程序开发与系统架构领域中高可用系统搭建相关资料进行整理，更多的其他相关优秀资料可以参考笔者的 Awesome Reference 系列，其他的还包括追求技术之上的进阶阅读学习索引 、 机器学习、深度学习与自然语言处理领域推荐的书籍列表等等。 概览 2017-The System Design Primer: Learn how to design large scale systems. Prep for the system design interview. 2017-大话程序猿眼里的高并发：高并发是指在同一个时间点，有很多用户同时的访问URL地址，比如：淘宝的双11，双12，就会产生高并发,如贴吧的爆吧，就是恶意的高并发请求，也就是DDOS攻击，再屌丝点的说法就像玩撸啊撸被ADC暴击了一样,那伤害你懂得(如果你看懂了，这个说法说明是正在奔向人生巅峰的屌丝。 2017-微信高并发资金交易系统设计方案——百亿红包背后的技术支撑：本文将为读者介绍百亿级别红包背后的系统高并发设计方案，包括微信红包的两大业务特点、微信红包系统的技术难点、解决高并发问题通常使用的方案，以及微信红包系统的高并发解决方案。 2017-如何提升Web后端性能？我的4个实践和总结：随着互联网的不断发展，日常生活中越来越多的需求通过网络来实现，从衣食住行到金融教育，从口袋到身份，人们无时无刻不依赖着网络，而且越来越多的人通过网络来完成自己的需求。作为直接面对来自客户请求的Web服务端，无疑是要同时承受更多的请求，并为用户提供更好的体验。这个时候Web端的性能常常会成为业务发展的瓶颈，提升性能刻不容缓。本文作者在开发过程中总结了一些提升Web服务端性能的经验，与大家分享。 2017-去哪儿-超时，重试，熔断，限流 性能压测 open-source-database-testing-tools 扛住100亿次请求？我们来试一试 蚂蚁金服技术专家对性能优化的常见模式及趋势的思考 高并发性能调试经验分享 基于Locust、Tsung的百万并发秒杀压测案例 如何生成每秒百万级别的 HTTP 请求？&gt; 模拟百万级TCP并发 性能测试应该怎么做？ 负载均衡 Nginx/LVS/HAProxy负载均衡软件的优缺点详解 Google 是如何做负载均衡的？ 分布式系统中负载均衡算法在高可用场景下的分析 多种负载均衡算法及其Java代码实现 负载均衡的那些算法们 Nginx 负载均衡系列 章文嵩（正明）博士和他背后的负载均衡(LOAD BANLANCER)帝国 荔枝FM架构师刘耀华：异地多活IDC机房架构 异地多活设计难？其实是你陷入了这四大误区出不来！ 缓存 缓存架构设计细节二三事 缓存使用总结 2017-美团-缓存那些事：在网络分层应用服务中，缓存的使用已比较普及，本文将结合作者实际工作经验总结，讲述在不同的场景下如何选择和使用适用的缓存框架，以达到提升服务质量，优化系统架构的目的。 你有自己的Web缓存知识体系吗？ 缓存架构设计细节二三事 腾讯互娱技术总监：不止于思路，谈高性能服务器架构之道中的缓存策略 缓存系统在游戏业务中的特异性 深入浅出Cache Caching Explained 服务容错 服务容错模式 亿级 Web 系统的容错性建设实践 系统降级 服务降级背后的技术架构设计 秒杀应对 2016-携程-一个经验证可落地的秒杀系统实践思路 ：为什么要做秒杀？这个不难解释，最起码对于互联网电商业务来说很常见，那怎么样才能设计出相对比较完善的秒杀策略呢？我觉得这其中有两个关键。 2016-淘宝-大秒系统设计详解|许令波|文末有福利：最初的秒杀系统的原型是淘宝详情上的定时上架功能，由于有些卖家为了吸引眼球，把价格压得很低。但这给的详情系统带来了很大压力，为了将这种突发流量隔离，才设计了秒杀系统，文章主要介绍大秒系统以及这种典型读数据的热点问题的解决思路和实践经验。 秒杀系统架构分析与实战 乐视秒杀：每秒十万笔交易的数据架构解读 阿里价值“千万”的秒杀场景参数优化 四种框架分别实现百万websocket常连接的服务器 七种WebSocket框架的性能比较 秒杀系统架构优化思路]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F22%2F%E7%A0%B4%E8%A7%A3APK%2F</url>
    <content type="text"><![CDATA[##破解APK 技术分析[转] 某天，我把我的安卓手机设置开启了USB调试模式，然后从应用商店中下载了自动售货机APP，并把原始APP的apk文件转储到笔记本电脑中，用adb去调试分析： # adb pull /data/app/com.sitael.vending-1/base.apk ./Argenta.apk 用apktool对它进行反编译： # apktool d ./Argenta.apk ./Argenta 再用 jadx提取出其中的java源文件： # jadx ./Argenta.apk AndroidManifest.xml清单文件是每个Android程序中必须的文件，它是整个Android程序的全局描述文件，除了能声明程序中的Activities，Content Providers，Services，和Intent Receivers，还能指定应用的名称、使用的图标、包含的组件以及permissions和instrumentation（安全控制和测试）。这里，一开始，需要把AndroidManifest.xml文件中的调试属性更改为ture，之后才可在手机上进行调试，也就是往application 标签中添加一行 android:debuggable=”true” 属性。 接下来, 重建apk文件： # apktool b ./Argenta 然后用工具keytool来创建一个新的密钥： # keytool -genkey -v -keystore Argenta.keystore -alias Argenta -keyalg RSA -keysize 2048 -validity 10000 接着，使用该创建密钥，用jarsigner来对整个apk文件进行签名： # jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore Argenta.keystore Argenta.apk Argenta 再用工具zipalign来对apk程序文件进行优化 # zipalign -v 4 Argenta.apk Argenta-signed.apk 最后，就可以安装这个重建好的apk文件了。 # adb install ./Argenta-signed.apk 我在手机上安装运行了这个APP程序，并用工具logcat，通过包名对其程序日志进行过滤分析： # adb logcat –pid=adb shell pidof -s com.sitael.vending 但是，没什么收获，我打算再从其源代码中看看能有什么线索。从AndroidManifest.xml文件中，我发现了指向RushOrm的多个引用。 所以，这里首先我找的关键字就是db_name，从这里我发现了argenta.db的影子： 接下来，在手机中，我用工具Root Explorer继续来看看这个argenta.db，真的是存在的： 然后，我用adb pull方式把手机中的这个文件拷贝到笔记本电脑中来分析： # adb pull /data/data/com.sitael.vending/databases/argenta.db ./db 并尝试用SQLite的数据库浏览工具SQLiteBrowser来打开这个db文件： 哦，显然，它是有密码保护的，打不开。 逆向工程在源代码中，我分析了RushAndroidConfig.java： 从其中，我竟然发现了配置数据库的各种方法（method），但是，其中这个键值引起了我的注意： this.encryptionKey = getDeviceId(context) 它的定义如下： 从上图信息中可知，目标APP程序使用了手机的IMEI串号作为了上述SQLite数据库argenta.db的加密密钥，通常的手机，在键盘上输入*#06#就可得本身串号。那么，我们用手机串号来试试吧，看看能否能把数据库文件打开： 哇，真的可以啊： 经过一番检查，我找到了UserWallets这个表： 并对其中的walletCredit一栏做了修改，把它从0改为了5（5欧元）： 然后，我再把这个数据库文件拷贝回手机APP中： # adb pull ./argenta.db /data/data/com.sitael.vending/databases/argenta.db 破解验证此时，YY一下，我的感觉就像游戏帝国时代（Age Of Empires）中的“罗宾汉”一样，可以随便拥有1000枚金币。好吧，还是先来写个小程序吧，通过这个程序，可以快捷地对目标APP数据库进行转储/恢复/篡改： 接下来，我们就带上手机，去自动售货机那试试看吧！呵呵，竟然成功地买了一瓶矿泉水，真的可以用其中的5块钱顺利地进行消费，还能反复消费使用！ https://www.youtube.com/watch?v=LfczO8_RfLA 总结从APP账户中的0元，到之后破解APP数据库后，我可以进行以下操作： 修改APP账户的金额 任意购买自动售货机中的东西 继续用余额购买 余额为0之后可重新更改余额 如此重复消费购买自动售货机中的商品 在对整个APP源代码做了大概分析之后，我发现其中的很多代码都未做混淆编码，这意味着，售货机厂商没有采取很好的措施来对用户数据和应用程序安全实行保护。 再三纠结 ，一个月后，出于白帽的心态，我还是向售货机厂商报告了这个漏洞，我也礼貌性地建议他们抛弃当前的APP架构，从头开发一个更好、更安全的程序。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F22%2FSaaS%20%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[SaaS 特点###（1）公有云SaaS比传统本地安装软件的优点 ####一、产品体验 1、SaaS：因为是要年年续费，所以需要不断黏住客户，与客户同步进化 2、本地安装：一锤子买卖，8-10年后才能再换代大升级大实施。所以尽量软件功能做的多做的复杂一些，好多谈判多卖钱 二、研发速度1、SaaS：一套标准代码，每日迭代持续更新上线，变化效率很高。 2、本地安装：安装到天南海北客户本地后，出了Bug后不好诊断不好补丁，所以需要非常严格且长周期的测试，所以一年只能做2个大版本 三、客户1、SaaS：因为SaaS不需要先前购买服务器&amp;系统软件等IT采购，所以可以绕过企业IT部门，直接对口业务部门，限期免费网上试用，好用实用了再购买正式版本，网上充值后就直接网上开通、直接使用。 2、本地安装：过去得通过企业IT部门做桥梁，IT部门来做需求管理、项目管理、资源整合对接管理，IT部门来搞IT预算，IT部门做选型评审和验收评审。这样导致沟通效率很漫长、信息传递失真。 ####四、License收入 1、SaaS：现在在云端管理License和服务器端代码，谁也没法盗版和少开通License许可 2、本地安装：会遭遇盗版破解或License许可购买不足 ####五、实施安装部署配置 1、SaaS：运行在公有云上的，由总部高级工程师研发自动化脚本，来做大规模自动化部署。而且总部SaaS运维工程师会不断进行后台数据洞察，总结自动化脚本模板，让安装部署和应用系统初始化更加方便 2、本地安装：由各地层次不齐低工资低水平的实施顾问来安装部署，安装部署配置质量很差。况且，现在的分布式技术的复杂性，也让过去的实施顾问不会分布式安装了，难度太高。 ####六、技术支持服务 1、SaaS：云端随时埋点、监控、预警，随时发现问题随时优化和升级 2、本地安装：只有出了严重问题，客户打来电话，才知道客户出问题了，才远程连接客户的服务器甚至需要飞到客户现场去，成本、效率、质量、客户满意度都不好 ###（2）公有云SaaS需要传统本地安装软件人了解的东西 ####一、架构 1、SaaS：SaaS是多租户技术架构的，对分布式并发技术和海量存储技术门槛非常高，这是很多传统企业软件商没有的技术力量 2、本地安装：一个企业一套，安装实施、升级更新、配置变更、运维诊断支持，成本太高，工作效率也不行 ####二、产品 1、SaaS：SaaS是尽量外向型应用的，多多连接企业外部关联方。 2、本地安装：主要做企业内部应用，而且需要为各个企业做一定量的定制开发/集成开发/统计报表制作，并不是纯产品，而是产品+项目 ####三、报价 1、SaaS：含IaaS服务器&amp;存储&amp;路由器&amp;网络流量&amp;服务器操作系统&amp;数据库&amp;中间件&amp;安全设备成本均摊 2、本地安装：过去是客户自己购买服务器&amp;存储&amp;路由器&amp;系统软件&amp;数据库&amp;中间件。现在是系统集成公司来实施安装、来运维，并且收实施费和维保费的 ###（3）公有云SaaS的误区 ####一、SaaS就是软件？ 咱们上述已经说了，客户看到的是SaaS具体应用，但是这个SaaS需要运行在IT硬件上，过去IT硬件是客户自己采购，现在是SaaS软件商自己采购自己运维自己承担这个成本，所以SaaS软件成本中应该包含硬件成本和运维成本。 ####二、SaaS就是多个企业共用一套？ 对于大型企业和巨型企业，从技术原理上来说确实可以在专属云环境上专门独立部署一套，也可以部署到企业的IDC私有云上。但这里有个前提，就是必须接受SaaS商统一的大规模自动化运维监控、预警、升级、备份等等统一策略。 过去做的是企业内部应用，所以也没多少数据和用户并发，现在SaaS主要是给产业、给广大消费者外部应用的，所以有大量的分布式并发计算和海量实时数据，这种技术部署难度运维难度是非常高的。对于中型、中小型的企业，还是接受多个企业共用一套比较省事，等真的成长为大型企业了，确实业务并发量上去了，可以拆分出来单独专属云部署。 ####三、SaaS就是分期租用？ 过去传统软件，是一旦购买了特定的版本、做了安装部署、正常使用开，就很难再不断持续进化了。所以需要每8-10年甚至5年后，就需要重新购买一套最新功能的版本重新实施。所以很多人认为SaaS就是把未来5-10年的费用分期到每一年，就是现在SaaS的租用费。其实这是拿传统软件模式在看SaaS。 SaaS因为不是一锤子买卖，所以无需急着赶着做很多功能，而是与客户一起进化，持续迭代改进，所以也就没有所谓的5-10年生命期。所以是持续续掏使用费而非分期租用。 ####四、SaaS不好集成开发？ 现在大的SaaS商都有PaaS集成平台，用于单点登录集成、统一消息集成、工作流集成、报表集成、云SaaS API集成、互联网电子商务API集成、ERP集成。还有专门的数据传输队列分布式中间件，用于内外数据的同步。 ####五、SaaS不好数据导出迁移？ 现在大的SaaS商都有大数据平台、主数据平台，专门用于数据清洗、数据画像标签、数据导入导出、数据实时计算处理。 ####六、SaaS不好有数据安全隐患？ 刚才就说了，SaaS的应用是适合天然的外向型应用：人与企业的连接、设备与企业的连接、企业和企业的连接。这和天猫开店是一样的，耐克、海尔、李宁等等都在天猫上开店。这些品牌商在天猫的官方旗舰店，销售情况、财务情况、库存情况、评价情况，其实天猫全都知道，都在天猫后台集中的数据库中。但为什么没有这些大品牌企业反映所谓的数据安全隐患？所以说，这里的核心是，首先你确实要做好各种安全防护、安全认证、安全测试、安全保险理赔，更重要的是，你的应用一定是外向型业务：带有营销、交易、金融、全盘资源调度、招聘的味道。只有真正为企业带来业绩价值，利大于弊，才会不非揪着数据安全不放。 ####（4）中国企业服务商业模式 很多人说在中国做SaaS真是没有前途，明明SaaS商包含了IaaS和PaaS数据库中间件操作系统成本，但客户就当应用软件价格购买，而且还就当分期租用切片购买付费。卖一套ERP可以卖上500万可以一次性拿很多提成，卖一套SaaS只能一次收50万块钱，没有销售积极性啊。 所以，在中国，为了销售积极性，为了客户不纠结是公有云部署还是私有本地部署、不纠结数据安全隐患，中国的SaaS也必须搞外向型应用。 而且，还必须羊毛出在狗身上，还必须借助SaaS来结网：人、企业、智能产品&amp;智能设备，来沉淀数据，去做大数据+AI深度学习驱动的业务服务和金融保险服务。很多做企业IT人说我的观点是歪门邪道不务正业，但我恰恰需要立足在中国政府、中国企业这片土地现状上，真正去解决问题，真正为客户核心业务价值而服务。我们企业IT人口口声声说要以客户为中心，要打洞而不是给客户卖一把钻头（这是个知名的梗），但是真正要求大家去打洞而非只卖钻头时，大家又支支吾吾说我只会制作钻头不会打洞，我只赚钻头的钱。这是真正为客户核心业务价值而服务吗？ 所以说，ITSaaS、智能传感器直接数据采集（为了自动化实时采集数据而不是人工累哈哈的录入数据校对数据），再加上大数据人工智能深度学习驱动的业务服务和金融保险服务，这才是中国企业服务的正确之路。再次说一遍，现在火的是企业服务，而不是企业软件，这话我已经说了5年了。 ####（5）SaaS的本质：大数据 上述说起SaaS，都是什么开发、实施、运维技术支持的效率、成本、质量、客户满意度的优化。从本质来讲，这叫改善，不叫上台阶质变。 但SaaS有个天然绝佳优势，就是可以汇集全产业数据、全网数据，甚至可以汇集全社会的数据，如互联网&amp;电子商务的数据、地图数据、电信运营商数据、政府事业单位数据，这些360度数据汇集在一起，我们就可以做真正的大数据驱动的业务PDCA，而非人工搞业务的PDCA。我们不仅可以和我们过去的经营情况相对比，我们更可以和行业最佳企业比，和行业平均中位数企业比，甚至可以和友商比较。]]></content>
  </entry>
  <entry>
    <title><![CDATA[opencv]]></title>
    <url>%2F2018%2F10%2F21%2Fopencv%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F18%2FSpringCloud%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[SpringCloud提供的功能SpringCloud提供的功能包括：配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等。 1.Eureka 说明 高可用组件，没有后端缓存，每一个实例注册之后需要向注册中心发送心跳。默认情况下Eureka Server也是一个Eureka Client，必须要指定一个Server. 2.Starters Spring Boot 启动项目，为Spring Cloud提供开箱即用的依赖管理。 3.Ribbon 提供远端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。 4.Feign 项目中包含Ribbon，因此也提供了负载均衡能力。它也是一种声明式、模板化的HTTP客户端。 5.Connectors 便于远端应用程序在各个pass平台连接到后端，如数据库和消息代理服务。 6.Zuul 说明 Zuul主要功能是 路由转发和过滤器。其配合Ribbon共同完成负载均衡。在Zuul中继承了ZuulFilter后，进行访问是，只有ZuulFilter校验通过了，才会进行后续Servlet服务的初始化。 7.Config 说明 配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git、Subversion。 config-server和config-client 在properties文件中添加远程配置中心如$[git]$等 http请求地址和资源文件映射如下：$$\begin{align}/{applicaion}/{profile}[/{label}]\tag{1}\ /{applicaion}-{profile}[/{label}]\tag{2}\ /{label}/{applicaion}-{profile}\tag{3}\/{applicaion}-{profile}.properties\tag{4}\ /{label}/{applicaion}-{profile}.properties\tag{3}\\end{align}$$8.Bus 说明 事件、消息总线，用于在集群中传播状态变化、可与Config联合实现热部署。 9.Hystrix 说明 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。 10.Archaius 说明 配置管理API：包含一系列配置管理API，提供动态类型化属性，线程安全配置操作、轮询框架、回调机制等功能。 11.Cloud Foundry 说明 通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源Paas云平台。 12.Security 说明 基于SpringSecurity的安全工具包，为应用程序添加安全控制。 13.Consul 说明 封装了Consul操作，consul是一个服务发现与配置工具，与Docker可以无缝集成。 14.Zookeeper 说明 操作Zookeeper的工具包，用于使用Zookeeper方式的服务发现和配置管理。 15.Sleuth 说明 日志收集工具，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。 16.Data Flow 说明 大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。 17.Stream 说明 数据流操作开发包，封装了与Redis，Rabbit，Kafka等发送接收消息。 18.Task 说明 提供云端计划任务管理，任务调度。 19.Turbine 说明 Turbine是服务器发送事件流数据的一个工具，用来监控集群下Hystrix的metrics情况。 20.Cluster 说明 提供Leadership选举，如：Zookeeper，Redis，Hazeicast，Consul等常见状态模式的抽象和实现。 特点 约定由于配置 开箱即用，快速启动 适用于各种环境 轻量级组件 组建支持丰富，功能齐全]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F15%2FChannel%2F</url>
    <content type="text"><![CDATA[Channel1.1常用方法说明123456789101112131415161718192021222324252627282930313233343536373839404142private static Channel channels = new DefaultChannelGroup(GlobalEventExectors.INSTANCE);@override //加入public void handlerAdded(ChannelHandlerContext ctx)throws Exception&#123; Channel joinChannel = ctx.channel(); for(Channel channel:channels)&#123; sout("Address: " + channel.remoteAddress() +"加入服务端……"); &#125; channels.add(joinChannel);&#125;@override //移除public void HandlerRemove(ChannelHandlerContext ctx)throws Exception&#123; Channel removeChannel = ctx.channel(); for(Channel channel:channels)&#123; sout("Address: " + channel.remoteAddress() +"加入服务端……"); &#125; channels.add(removeChannel);&#125;@override //读取完成public void ChannelReadComplete(ChannelHandlerContext ctx)throws Exception&#123; &#125;@override //在线public void ChannelActive(ChannelHandlerContext ctx)throws Exception&#123; &#125;@override //不在线public void ChannelInActive(ChannelHandlerContext ctx)throws Exception&#123; &#125;@override //异常处理public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception &#123; Channel incoming = ctx.channel(); System.out.println("SimpleChatClient:"+incoming.remoteAddress()+"异常"); // 当出现异常就关闭连接 cause.printStackTrace(); ctx.close();&#125; 2.引用计数1234567891011121314151617181920212223242526272829ByteBuf buf = ctx.alloc().directBuffer();//新创建的引用对象的初始值为1assert buf.refCnt()==1;boolean destoryed = buf.release();//释放引用计数对象，引用次数就减1，为0时就归还到创建它的对象池//引用技术对象未销毁时，可以通过retain()方法增加引用次数buf.retain();assert buf.refCnt() == 2;//销毁对象通过最后访问引用计数对象的部分负责对象的销毁buf.release();assert buf.refCnt() == 1;//子缓冲区 duplicate(),slice(),order(ByteOrder)方法会创建一个子缓冲区，子缓冲区共享父缓冲区的内存区域。子缓冲区没有自己的引用技术，而是共享父缓冲区的引用计数ByteBuf derived = buf.duplicate();assert buf.refCnt() == 1;assert derived.refCnt() == 1;//buf.copy()和buf.readBytes(int)创建的不是子缓冲区，因此返回的ByteBuf需要释放。由于父缓冲区和子缓冲区共享引用技术，因此在将子缓冲区对象传递到其他组件时，需要先调用retain() ByteBuf parent = ctx.alloc().directBuffer(); parent.writeByte(16); try&#123; while(parent.isReadable(16))&#123; ByteBuf derived = parent.readSlice(16); derived.retain(); process(derived); &#125; &#125; finally&#123; parent.release(); &#125;public void process(ByteBuf buf)&#123; buf.release();&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F12%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[一：渐进符号1.1 符号的辨析1.1.1 符号$O$$O$,读作“大O”,非正式来说，$O(g(n))$是增长次数小于等于$g(n)$及其常数倍($n$趋向于无穷大)的函数集合。 定义 如果函数$f(n)$包含在$O(g(n))$中，记作$f(n)∈o(g(n))$ (平时使用为了方便书写，我们通常使用$f(n)=o(g(n)))$代替)。它的成立条件是：对于所有足够大的$n$,$f(n)$上界由$g(n)$的常数倍确定，也就是说：存在大于$O$的常数$c$和非负整数$n_0$，使得对于所有的$n≥n_0$来说，$f(n)≤c(g(n))$。 下图说明了这个定义： 下面给出几个例子：$$\begin{align}n&amp;=O(n^2)\tag{1.1.1.1}\100n+5&amp;=O(n^2)\tag{1.1.1.2}\\frac 12n(n-1)&amp;=O(n^2)\tag{1.1.1.3}\n^3&amp;≠O(n^2)\tag{1.1.1.4}\0.00001n^3&amp;≠O(n^2)\tag{1.1.1.5}\end{align}$$ 1.1.2 符号$Ω$$Ω$读作”omega”,$Ω(g(n))$是增长次数大于等于$g(n)$及其常数倍($n$趋向于无穷大)的函数集。 定义 如果函数$f(n)$包含在$Ω(g(n))$中，记作$f(n)=Ω(g(n))$。它的成立条件是：对于所有足够大的$n$,$f(n)$的下届由$g(n)$的常数倍确定，也就是说，存在大于$0$的常数$c$和非负整数$n_0$，使得对于所有的$f(n)≥c g(n)$。 下图说明了这个定义： 下面给出几个例子：$$\begin{align}n^3&amp;=Ω(n^2)\tag{1.1.2.1}\\frac 12n(n-1)&amp;=Ω(n^2)\tag{1.1.2.2}\100n+5&amp;=Ω(n^2)\tag{1.1.2.3}\\end{align}$$ 1.1.3 符号$θ$$θ$读作”theta”。 定义 如果函数$f(n)$包含在$θ(g(n))$中，记作$f(n)=θ(g(n))$。它的成立条件是：对于所有足够大的$n$，$f(n)$的上界和下界由$g(n)$的常数倍所确定，也即是说：存在大于$0$的常数$c_1,c_2$和非负整数$n_0$，使得对于所有的$n≥n_0$来说，$c_1·g(n)≤f(n)≤c_2·g(n)$。 下图说明了这个定义： $$\begin{align}\frac 12n(n-1)&amp;=θ(n^2)\tag{$c_1=\frac 14,c_2=\frac 12,n_0=2$}\6n^3&amp;≠θ(n^2)\tag{1.1.3.2}\\end{align}$$ 1.2 符号的性质定理 如果$t_1(n)=O(g_1(n))$并且$t_2(n)=O(g_2(n))$，则:$$t_1(n)+t_2(n)=O(\max{g_1(n),g_2(n)})$$对于$Ω$和$θ$同样成立。 证明 增长次数的证明是基于以下事实：对于$4$个任意的实数$a_1,b_1,a_2,b_2$,如果$a_1≤b_1$并且$a_2≤b_2$，则$a_1+a_2≤2\max{b_1,b_2}$。 因为$t_1(n)=O(g_1(n))$，所以在正常量$c_1$和非负整数$n_1$，使得对于所有的$n≥n_1$，有$t_1(n)≤c_1g_1(n)$。同理，因为$t_2(n)=O(g_2(n))$，对于所有的$n≥n_2$，亦有$t_2(n)≤c_2g_2(n)$。 假设$c_3=\max{c_1,c_2}$并且$n≥\max{n_1,n_2}$，就可以利用两个不等式的结论将其相加，得出以下结论：$$\begin{align}t_1(n)+t_2(n)&amp;≤c_1g_1(n)+c_2g_2(n)\tag{1.2.1}\ &amp;≤c_3g_1(n)+c_3g_2(n)=c_3[g_1(n)+g_2(n)]\tag{1.2.2}\ &amp;≤c_3·2\max{g_1(n),g_2(n)}\tag{1.2.3} \end{align}$$那么，对于两个连续执行部分组成的算法，应该如何应用这个特征呢？它意味着该算法的整体效率是由具有较大增长次数的部分所决定的，即效率较差的部分决定。 二：计算复杂度对于一个普通的函数(即非递归函数)，其时间复杂度自然易求。下面说下递归函数的时间复杂度。 递归函数的时间复杂度有以下的方程式 :$$T(n)=aT(\frac nb)+f(n)\tag{2.1}$$其中，$a≥1,b&gt;1$并且都是常数，$f(n)$是渐进正函数。递归式$(2.1)$描述的是这样一种算法的运行时间：它将规模为$n$的问题分解为$a$个子问题，每个子问题规模为$\frac nb$，其中$a≥1,b&gt;1$。$a$个子问题递归地求解，每个花费的时间$T(\frac nb)$。函数$f(n)$包含了问题分解和子问题解合并的代价。 解决以上方程式常用的方法有两种：主定理和分治法。 2.1 主定理(Master Theorem)定理 令$a≥1,b&gt;1$且都是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式，即:$$T(n) = aT(\frac nb)+f(n)$$其中，我们将$\frac nb$解释为$⌊\frac nb⌋$或$⌈\frac nb⌉$。那么$T(n)$有如下渐近界： (Case 1) 如果$f(n)=O(n^c)$，其中$c&lt;log_ba$，则：$$T(n) = θ(b^{log_ba})$$(Case 2) 如果存在常数$k≥0$，使$f(n)=θ(n^clog^{k}n)$，其中$c=log_ba$，则：$$T(n)=θ(n^clog^{k+1}n)$$ (Case 3) 如果$f(n)=Ω(n^c)$，其中$c&gt;log_ba$，并且对某个常数$k&lt;1$和所有足够大的$n$有$af(\frac nb)≤kf(n)$，则： $$T(n)=θ(f(n))$$ 算法导论已有关于这个定理的证明，篇幅较长，故此处省略，有兴趣的读者可以自己去翻阅下。 2.2 分治法分治法先把给定的实例划分为若干个较小的实例，对每个实例递归求解，然后如果有必要，再把较小实例的解合并成给定实例的一个解。假设所有较小实例的规模都为$\frac nb$，其中$a$个实例需要实际求解，对于$n=b^k,k=1,2,3…$，其中$a≥1,b&gt;1$，得到以下结果： $$\begin{align}T(n)&amp;=aT(\frac nb)+f(n)\tag{原始递归方程式}\T(b^k)&amp;=aT(b^{k-1})+f(b^k)\tag{2.2.2}\ &amp;=a[aT(b^{k-2})+f(b^{k-1})]+f(b^k)=a^2T(b^{k-2})+af(b^{k-1})+f(b^k)\tag{2.2.3}\ &amp;=a^3T(b^{k-3})+a^2f(b^{k-2})+af(b^{k-1})+f(b^k)\tag{2.2.4}\ &amp;=…\tag{2.2.5}\ &amp;=a^kT(1)+a^{k-1}f(b^1)+a^{k-2}f(b^2)+…+a^0f(b^k)\tag{2.2.6}\ &amp;=a^k[T(1)+\sum_{j=1}^{k} {\frac {f(b^j)}{a^j}}]\tag{2.2.7}\end{align}$$ 由于$a^k=a^{log_bn}=n^{log_ba}​$,当$n=b^k​$时，对于式$(2.2.7)​$我们可以推出下式： $$T(n)=n^{log_ba}[T(1)+\sum_{j=1}^{log_bn}{\frac {f(b^j)}{a^j}}]\tag{2.2.8}$$ 显然，$T(n)$的增长次数取决于常数$a$和$b$的值以及函数$f(n)$的增长次数。 三：常见的定理以下是常用的的两条定理，它们依旧建立在递归方程式中，即： $$T(n)=aT(\frac nb)+f(n)\tag{$a≥1,b&gt;1$}$$ 根据以上的方程式有以下两个定理： 3.1 定理1定理1 对于递归方程式，若$a=1,b&gt;1,f(n)=c,c$为某个常数，即： $$T(n)=T(\frac nb)+c$$ 则： $$T(n)=Θ(logn)$$ 证明 应用主定理 Case 2，其中$c=log_ba=log_b1=0​$，再使$k=0​$，则$f(n)=Θ(n^clog^kn)=Θ(1)​$，这里的$f(n)​$即等于常数$c​$，证明成立。 3.2 定理2定理2 对于递归方程式，若$a=1,b&gt;1,f(n)=kn+p$，其中$k&gt;0,p&gt;0$且为某个常数（也就是$f(n)$是一个线性直线方程），即： $$T(n)=T(\frac nb)+(kn+p)\tag{$b&gt;1,k&gt;0,p$为某个常数}$$ 则： $$T(n)=Θ(n)$$ 证明 应用分治法中式$(2.2.8)$： $$\begin{align}T(n)&amp;=n^{log_ba}[T(1)+\sum_{j=1}^{log_bn}{\frac {f(b^j)} {a^j}}]\tag{3.2.1}\&amp;=\sum_{j=1}^{log_bn}(kb^j+p)\tag{3.2.2}\&amp;=plog_bn+{\frac {kb}{b-1}(n-1)}\tag{k&gt;0,p&gt;0,b&gt;1}\&amp;&lt;pn+{\frac{kb}{b-1}(n-1)}\tag{3.2.4}\&amp;=cn - {\frac {kb}{b-1}}\tag{c&gt;0且为某个常数}\&amp;=θ(n)\tag{3.2.5}\end{align}$$ 证明成立。 四：总结第一部分辨析了$O,Ω,Θ$三种符号的区别以及它们的性质。 第二部分介绍了两种常用的计算时间复杂度方法，即主定理和分治法。 第三部分给出了生活中常见的两个定理，比较实用，希望读者能够熟记。]]></content>
  </entry>
</search>
